# 1. Ford-Fulkerson
# Finds the maximum flow from a source to a sink in a flow network using augmenting paths.
def ford_fulkerson_bfs(graph, s, t, parent):
    visited = [False] * len(graph)
    queue = []
    queue.append(s)
    visited[s] = True
    parent[s] = -1

    while queue:
        u = queue.pop(0)
        for v in range(len(graph)):
            if not visited[v] and graph[u][v] > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u

    return visited[t]

def FordFulkerson(graph, source, sink):
    n = len(graph)
    residual_graph = [row[:] for row in graph]
    parent = [0] * n
    max_flow = 0

    while ford_fulkerson_bfs(residual_graph, source, sink, parent):
        path_flow = float('Inf')
        s = sink
        while s != source:
            path_flow = min(path_flow, residual_graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow

        v = sink
        while v != source:
            u = parent[v]
            residual_graph[u][v] -= path_flow
            residual_graph[v][u] += path_flow
            v = parent[v]

    return max_flow

ff_graph = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]
print(f"Ford-Fulkerson Max Flow: {FordFulkerson(ff_graph, 0, 5)}")


# 2. Convex Hull
# Finds the smallest convex polygon that encloses a set of 2D points using the Graham scan.
def orientation(o, a, b):
    value = (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

    if value == 0:
        return 0

    return 1 if value > 0 else 2

def ConvexHull(points):
    points = sorted(points, key=lambda p: (p[1], p[0]))
    p0 = points[0]

    import math
    def angle(p):
        return math.atan2(p[1] - p0[1], p[0] - p0[0])

    points = sorted(points, key=angle)

    hull = []
    for p in points:
        while len(hull) >= 2 and orientation(hull[-2], hull[-1], p) != 1:
            hull.pop()
        hull.append(p)

    return hull

pts = [(0,0),(1,1),(2,2),(2,0),(1,2),(0,2)]
print(ConvexHull(pts))


# 3. N-Queens
# Solves the N-Queens problem using backtracking to find all placements of N queens on an N×N board.
def isSafe(board, row, col, n):
    for i in range(row):
        if board[i][col] == 1:
            return False

    i, j = row, col
    while i >= 0 and j >= 0:
        if board[i][j] == 1:
            return False
        i -= 1
        j -= 1

    i, j = row, col
    while i >= 0 and j < n:
        if board[i][j] == 1:
            return False
        i -= 1
        j += 1

    return True

def solveNQueens(n):
    board = [[0] * n for _ in range(n)]

    def solve(row):
        if row == n:
            for r in board:
                print(" ".join("Q" if x else "." for x in r))
            print()
            return
        
        for col in range(n):
            if isSafe(board, row, col, n):
                board[row][col] = 1
                solve(row + 1)
                board[row][col] = 0

    solve(0)

solveNQueens(4)


# 4. Matrix Chain Multiplication (MCM)
# Uses dynamic programming to find the most efficient way to multiply a chain of matrices.
def MCM(p):
    n = len(p) - 1
    dp = [[0] * (n + 1) for _ in range(n + 1)]

    for length in range(2, n + 1):
        for i in range(1, n - length + 2):
            j = i + length - 1
            dp[i][j] = float("inf")

            for k in range(i, j):
                cost = dp[i][k] + dp[k + 1][j] + p[i - 1] * p[j] * p[k]
                dp[i][j] = min(dp[i][j], cost)

    return dp[1][n]

p = [10, 30, 5, 60]
print(MCM(p))


# 5. KMP (Knuth-Morris-Pratt)
# Implements the KMP algorithm for efficient string matching using a precomputed LPS table.
def lps(pattern):
    m = len(pattern)
    lps = [0] * m
    j = 0
    i = 1

    while i < m:
        if pattern[i] == pattern[j]:
            j += 1
            lps[i] = j
            i += 1
        else:
            if j != 0:
                j = lps[j - 1]
            else:
                lps[i] == 0
                i += 1

    return lps

def kmp(string, pattern):
    n = len(string)
    m = len(pattern)

    lps_table = lps(pattern)

    i, j = 0, 0

    while i < n:
        if string[i] == pattern[j]:
            i += 1
            j += 1

        if j == m:
            print("Pattern found at index: ", i - j)
            j = lps_table[j - 1]
        elif i < n and string[i] != pattern[j]:
            if j != 0:
                j = lps_table[j - 1]
            else:
                i += 1

string = "ABABDABACDABABCABAB"
pattern = "ABABC"

kmp(string, pattern)


# 6. Huffman Coding
# Generates prefix-free codes for characters based on their frequency using a greedy approach.
import heapq

class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

def huffman(freq):
    heap = []

    for ch, fr in freq.items():
        heapq.heappush(heap, Node(ch, fr))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        merged = Node(None, left.freq + right.freq)
        merged.left = left
        merged.right = right

        heapq.heappush(heap, merged)

    root = heap[0]
    codes = dict()

    def generate(node, code):
        if node is None:
            return

        if node.char is not None:
            codes[node.char] = code
            return

        generate(node.left, code + "0")
        generate(node.right, code + "1")

    generate(root, "")
    return codes

freq = {'a' : 5, 'b' : 9, 'c' : 12, 'd' : 13, 'e' : 16, 'f' : 45}
codes = huffman(freq)

for ch in codes:
    print(ch, codes[ch])


# 7. Bellman-Ford
# Finds the shortest paths from a source vertex in a graph, handling negative edge weights.
INF = float("inf")

def BellmanFord(graph, V, source):
    dist = [INF] * V
    dist[source] = 0

    for _ in range(V - 1):
        for u, v, w in graph:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w

    for u, v, w in graph:
        if dist[u] != INF and dist[u] + w < dist[v]:
            print("This graph contains a negative edge cycle")
            return

    return dist

graph = [
    (0, 1, -1),
    (0, 2, 4),
    (1, 2, 3),
    (1, 3, 2),
    (1, 4, 2),
    (3, 2, 5),
    (3, 1, 1),
    (4, 3, -3)
]

print(BellmanFord(graph, 5, 0))


# 8. Karatsuba
# Implements the Karatsuba algorithm for fast multiplication using a divide and conquer approach.
def karatsuba(num1, num2):
   if num1 < 10 and num2 < 10:
       return num1 * num2

   n = max(len(str(num1)), len(str(num2)))
   mid = n // 2

   a = num1  // (10 ** mid)
   b = num1 % (10 ** mid)
   c = num2 // (10 ** mid)
   d = num2 % (10 ** mid)

   p1 = karatsuba(a, c)
   p2 = karatsuba(b, d)
   p3 = karatsuba(a + b, c + d)

   middle = p3 - p1 - p2

   return p1 * (10 ** (2 * mid)) + middle * (10 ** mid) + p2

print(karatsuba(100, 12))


# 9. Longest Common Subsequence (LCS)
# Finds the longest subsequence common to two sequences using dynamic programming.
def LCS(X, Y):
    n = len(X)
    m = len(Y)

    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])

    i, j = n, m
    seq = []
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            seq.append(X[i - 1])
            i -= 1
            j -= 1
        else:
            if dp[i - 1][j] > dp[i][j - 1]:
                i -= 1
            else:
                j -= 1
        
    seq.reverse()
    
    return dp[n][m], ''.join(seq)

X = "ABCBDAB"
Y = "BDCABA"

length, sequence = LCS(X, Y)
print(length)
print(sequence)


# 10. Line Segment Intersection
# Checks if two line segments intersect using orientation and collinearity checks.
def orientation(o, a, b):
    value = (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
    
    if value == 0:
        return 0

    return 1 if value > 0 else 2

def on_segment(a, b, c):
    on_x = min(a[0], c[0]) <= b[0] <= max(a[0], c[0])
    on_y = min(a[1], c[1]) <= b[1] <= max(a[1], c[1])

    return on_x and on_y

def intersect(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)

    if o1 != o2 and o3 != o4:
        return True

    if o1 == 0 and on_segment(p1, p2, q1): return True
    if o2 == 0 and on_segment(p1, q2, q1): return True
    if o3 == 0 and on_segment(p2, p1, q2): return True
    if o4 == 0 and on_segment(p2, q1, q2): return True

    return False

print(intersect((1, 1), (10, 1), (1, 2), (10, 2)))
print(intersect((10, 0), (0, 10), (0, 0), (10, 10)))
print(intersect((0, 0), (10, 10), (5, 5), (15, 15)))
print(intersect((0, 0), (5, 5), (6, 6), (10, 10)))


# 11. Max Subarray Sum
# Finds the maximum sum of a contiguous subarray using a divide and conquer approach.
def max_crossing_sum(arr, left, right, mid):
    s = 0
    left_sum = float("-inf")
    
    for i in range(mid, left - 1, -1):
        s += arr[i]
        left_sum = max(left_sum, s)

    s = 0
    right_sum = float("-inf")

    for i in range(mid + 1, right + 1):
        s += arr[i]
        right_sum = max(right_sum, s)

    return left_sum + right_sum

def max_subarray_sum(arr, left, right):
    if left == right:
        return arr[left]

    mid = (left + right) // 2

    left_sum = max_subarray_sum(arr, left, mid)
    right_sum = max_subarray_sum(arr, mid + 1, right)
    crossing_sum = max_crossing_sum(arr, left, right, mid)

    return max(left_sum, right_sum, crossing_sum)

arr = [-1, -2, 3, 4, 5, -1, 4, 3]
print(max_subarray_sum(arr, 0, len(arr) - 1))


# 12. Floyd-Warshall
# Finds all-pairs shortest paths in a graph using dynamic programming.
INF = float("inf")

def FloydWarshall(dist):
    n = len(dist)

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist

dist = [
    [0,   5,   INF, 10],
    [INF, 0,   3,   INF],
    [INF, INF, 0,   1],
    [INF, INF, INF, 0]
]

result = FloydWarshall(dist)

for row in result:
    print(row)


# 13. Rabin-Karp
# Implements the Rabin-Karp string matching algorithm using a simple rolling sum hash.
def RabinKarp(string, pattern):
    n = len(string)
    m = len(pattern)

    string_hash = 0
    pattern_hash = 0

    for i in range(m):
        string_hash += ord(string[i])
        pattern_hash += ord(pattern[i])

    for i in range(n - m + 1):
        if string_hash == pattern_hash:
            if string[i : i + m] == pattern:
                print("Match found at position: ", i)

        if i + m < n:
            string_hash -= ord(string[i])
            string_hash += ord(string[i + m])

string = "ABCBBBCBCBBACBABCBABC"
pattern = "ABC"

RabinKarp(string, pattern)


# 14. Naive String Matching
# Finds all occurrences of a pattern in a string using a simple brute-force check.
def naive(string, pattern):
    n = len(string)
    m = len(pattern)

    for i in range(n - m + 1):
        if string[i : i + m] == pattern:
            print("Match found at position: ", i)

string = "ABCBBBCBCBBACBABCBABC"
pattern = "ABC"

naive(string, pattern)
